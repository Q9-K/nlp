![ * 博客 * 下载 * 学习 * 社区 * ![GitCode ](_source%3Dcsdn_toolbar) * InsCodeAI * 会议
搜索
AI 搜索
登录 会员·新人礼包 ![ ]()
消息
历史
[ 创作中心 ]( "创作中心")
创作
# 【Redis】zset全攻略带你快速掌握：从常见命令到应用场景
![]()
爱吃烤鸡翅的酸菜鱼](_81073317 "爱吃烤鸡翅的酸菜鱼") ![ 于 2025-10-27 18:53:33 发布
!]() 阅读量439 ![ ![]() 收藏 11
!]() ![ 点赞数 12
CC 4.0 BY-SA版权
分类专栏： redis 文章标签： redis 数据库 缓存 后端 java
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
本文链接： ![ redis 专栏收录该内容 ](_81073317/category_13014924.html "redis")
6 篇文章
订阅专栏
![]()
## 1.前言
在Redis的五种基本数据类型中，zset（有序集合）是最具业务价值的结构之一。它像一个既能自动排序又能快速定位的超级列表，完美解决了"既要去重又要排序"的经典难题。无论是电商平台的销量排行榜、短视频APP的热门推荐，还是分布式系统的延迟任务调度，zset都凭借其独特的"分数排序+快速访问"特性成为开发者的首选工具。今天我们就从基础命令到底层实现，全方位掌握这个Redis中的"排序大师"。
* * *
## 插播一条消息~
**十年经验淬炼 · 系统化AI学习平台推荐**
系统化学习AI平台![]( "系统化学习AI平台")
> * **完整知识体系：** 从数学基础 → 工业级项目（人脸识别/自动驾驶/GANs），内容由浅入深
> * **实战为王：** 每小节配套可运行代码案例（提供完整源码）
> * **零基础友好：** 用生活案例讲解算法，无需担心数学/编程基础
>
** 特别适合**
> * 想系统补强AI知识的开发者
> * 转型人工智能领域的从业者
> * 需要项目经验的学生
>
* * *
## 2.正文
### 2.1常见命令
zset的命令体系围绕"分数(score)"和"成员(member)"两个核心概念展开，我们可以把它想象成一个高考成绩榜：每个考生是member，分数是score，zset自动按分数排序并提供各种查询方式。
#### 2.1.1zadd
**定义** ：向有序集合添加一个或多个成员，或者更新已存在成员的分数
**语法** ：
```
zadd key score member [score member ...]
AI写代码bash
```
**示例** ：
``` 1. # 添加单个成员 2. 127.0.0.1:6379> zadd student_scores 95 "张三" 3. (integer) 1 4. # 批量添加成员 5. 127.0.0.1:6379> zadd student_scores 88 "李四" 92 "王五" 76 "赵六" 6. (integer) 3 7. # 更新已有成员分数(NX:只添加不存在的成员，XX:只更新已存在的成员) 8. 127.0.0.1:6379> zadd student_scores XX 96 "张三" # 将张三分数更新为96 9. (integer) 1
AI写代码bash
![]()
```
* * *
#### 2.1.2zcard
**定义** ：获取有序集合的成员数量
**语法** ：
```
zcard key
AI写代码bash
```
**示例** ：
``` 1. 127.0.0.1:6379> zcard student_scores 2. (integer) 4 # 表示有4个学生成绩记录
AI写代码bash
```
* * *
#### 2.1.3zcount
**定义** ：计算在有序集合中指定分数区间的成员数量
**语法** ：zcount key min max
**示例** ：
``` 1. # 查询80-90分之间的学生数量 2. 127.0.0.1:6379> zcount student_scores 80 90 3. (integer) 1 # 只有李四(88分)在这个区间 4. # 使用"(min"表示不包含min，同理"(max"不包含max 5. 127.0.0.1:6379> zcount student_scores (88 95 6. (integer) 1 # 不包含88分，包含95分以下，这里是王五(92分)
AI写代码bash
```
* * *
#### 2.1.4zrange
**定义** ：通过索引区间返回有序集合指定区间内的成员（升序排列）
**语法** ：
```
zrange key start stop [WITHSCORES]
AI写代码bash
```
**示例** ：
``` 1. # 获取所有成员(0表示第一个，-1表示最后一个) 2. 127.0.0.1:6379> zrange student_scores 0 -1 3. 1) "赵六" 4. 2) "李四" 5. 3) "王五" 6. 4) "张三" 7. # 获取前三名并显示分数 8. 127.0.0.1:6379> zrange student_scores 0 2 WITHSCORES 9. 1) "赵六" 10. 2) "76" 11. 3) "李四" 12. 4) "88" 13. 5) "王五" 14. 6) "92"
AI写代码bash
![]()
```
* * *
#### 2.1.5zrevrange
**定义** ：通过索引区间返回有序集合指定区间内的成员（降序排列）
**语法** ：
```
zrevrange key start stop [WITHSCORES]
AI写代码bash
```
**示例** ：
``` 1. # 获取成绩前三名(降序) 2. 127.0.0.1:6379> zrevrange student_scores 0 2 WITHSCORES 3. 1) "张三" 4. 2) "96" 5. 3) "王五" 6. 4) "92" 7. 5) "李四" 8. 6) "88"
AI写代码bash
```
* * *
#### 2.1.6zrangebyscore
**定义** ：通过分数区间返回有序集合指定区间内的成员
**语法** ：
```
zrangebyscore key min max [WITHSCORES] [LIMIT offset count]
AI写代码bash
```
**示例** ：
``` 1. # 查询80分以上的学生，按分数升序 2. 127.0.0.1:6379> zrangebyscore student_scores 80 +inf WITHSCORES 3. 1) "李四" 4. 2) "88" 5. 3) "王五" 6. 4) "92" 7. 5) "张三" 8. 6) "96" 9. # 查询80-90分的学生，从第1个开始取2个(分页效果) 10. 127.0.0.1:6379> zrangebyscore student_scores 80 90 LIMIT 0 2 11. 1) "李四"
AI写代码bash
![]()
```
* * *
#### 2.1.7zpopmax
**定义** ：移除并返回有序集合中分数最高的成员
**语法** ：
```
zpopmax key
AI写代码bash
```
**示例** ：
``` 1. # 弹出分数最高的成员 2. 127.0.0.1:6379> zpopmax student_scores 3. 1) "张三" 4. 2) "96" 5. # 弹出分数最高的2个成员 6. 127.0.0.1:6379> zpopmax student_scores 2 7. 1) "王五" 8. 2) "92" 9. 3) "李四" 10. 4) "88"
AI写代码bash
![]()
```
* * *
#### 2.1.8bzpopmax
**定义** ：阻塞式移除并返回有序集合中分数最高的成员（当集合为空时会阻塞连接）
**语法** ：
```
bzpopmax key [key ...] timeout
AI写代码bash
```
**示例** ：
``` 1. # 尝试从空集合弹出，3秒超时 2. 127.0.0.1:6379> bzpopmax empty_set 3 3. (nil) 4. (3.00s) # 等待3秒后返回nil 5. # 另一个客户端在超时前添加数据 6. # 客户端2: zadd empty_set 100 "紧急任务" 7. # 客户端1会立即返回: 8. 1) "empty_set" 9. 2) "紧急任务" 10. 3) "100"
AI写代码bash
![]()
```
* * *
#### 2.1.9zpopmin
**定义** ：移除并返回有序集合中分数最低的成员
**语法** ：
```
zpopmin key
AI写代码bash
```
**示例** ：
``` 1. # 弹出分数最低的成员 2. 127.0.0.1:6379> zpopmin student_scores 3. 1) "赵六" 4. 2) "76"
AI写代码bash
```
* * *
#### 2.1.10bzpopmin
**定义** ：阻塞式移除并返回有序集合中分数最低的成员
**语法** ：
```
bzpopmin key [key ...] timeout
AI写代码bash
```
**示例** ：与bzpopmax用法类似，区别是操作分数最低的成员
* * *
#### 2.1.11zrank
**定义** ：返回有序集合中指定成员的排名（按分数升序，排名从0开始）
**语法** ：
```
zrank key member
AI写代码bash
```
**示例** ：
``` 1. # 先恢复数据: zadd student_scores 95 "张三" 88 "李四" 92 "王五" 76 "赵六" 2. 127.0.0.1:6379> zrank student_scores "王五" 3. (integer) 2 # 升序排名第2(0:赵六,1:李四,2:王五,3:张三)
AI写代码bash
```
* * *
#### 2.1.12zrevrank
**定义** ：返回有序集合中指定成员的排名（按分数降序，排名从0开始）
**语法** ：
```
zrevrank key member
AI写代码bash
```
**示例** ：
``` 1. 127.0.0.1:6379> zrevrank student_scores "王五" 2. (integer) 1 # 降序排名第1(0:张三,1:王五,2:李四,3:赵六)
AI写代码bash
```
* * *
#### 2.1.13zscore
**定义** ：返回有序集合中指定成员的分数
**语法** ：
```
zscore key member
AI写代码bash
```
**示例** ：
``` 1. 127.0.0.1:6379> zscore student_scores "张三" 2.
"95" # 返回字符串形式的分数
AI写代码bash
```
* * *
#### 2.1.14zrem
**定义** ：移除有序集合中的一个或多个成员
**语法** ：
```
zrem key member [member ...]
AI写代码bash
```
**示例** ：
``` 1. # 移除单个成员 2. 127.0.0.1:6379> zrem student_scores "赵六" 3. (integer) 1 # 成功移除1个成员 4. # 移除多个成员 5. 127.0.0.1:6379> zrem student_scores "李四" "王五" 6. (integer) 2 # 成功移除2个成员
AI写代码bash
```
* * *
#### 2.1.15zremrangebyrank
**定义** ：移除有序集合中指定排名区间内的所有成员
**语法** ：
```
zremrangebyrank key start stop
AI写代码bash
```
**示例** ：
``` 1. # 移除排名最后的2个成员(升序排名从2到-1) 2. 127.0.0.1:6379> zremrangebyrank student_scores 2 -1 3. (integer) 2 # 移除了2个成员
AI写代码bash
```
* * *
#### 2.1.16zremrangebyscore
**定义** ：移除有序集合中指定分数区间内的所有成员
**语法** ：
```
zremrangebyscore key min max
AI写代码bash
```
**示例** ：
``` 1. # 移除60分以下的成员 2. 127.0.0.1:6379> zremrangebyscore student_scores -inf 60 3. (integer) 0 # 没有符合条件的成员
AI写代码bash
```
* * *
#### 2.1.17zincrby
**定义** ：对有序集合中指定成员的分数进行增减
**语法** ：
```
zincrby key increment member
AI写代码bash
```
**示例** ：
``` 1. # 给张三加5分 2. 127.0.0.1:6379> zincrby student_scores 5 "张三" 3.
"100" # 加分后的分数 4. # 给李四减3分 5. 127.0.0.1:6379> zincrby student_scores -3 "李四" 6.
"85" # 减分后的分数
AI写代码bash
```
* * *
### 2.2集合间操作
zset支持对多个有序集合进行交集和并集运算，这在需要组合多个排序维度的场景非常有用（如综合多个榜单的排名）。
#### 2.2.1zinterstore
**定义** ：计算多个有序集合的交集并将结果存储在新的有序集合中
**语法** ：
```
zinterstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
AI写代码bash
```
**示例** ：
``` 1. # 创建两个课程的成绩集合 2. 127.0.0.1:6379> zadd math_scores 90 "张三" 85 "李四" 95 "王五" 3. (integer) 3 4. 127.0.0.1:6379> zadd english_scores 88 "张三" 92 "李四" 80 "王五" 75 "赵六" 5. (integer) 4 6. # 计算两科成绩交集(取都参加考试的学生)，默认SUM聚合(分数相加) 7. 127.0.0.1:6379> zinterstore total_scores 2 math_scores english_scores 8. (integer) 3 # 3个共同学生 9. # 查看总分排名 10. 127.0.0.1:6379> zrange total_scores 0 -1 WITHSCORES 11. 1) "王五" 12. 2) "175" # 95+80=175 13. 3) "张三" 14. 4) "178" # 90+88=178 15. 5) "李四" 16. 6) "177" # 85+92=177 17. # 使用WEIGHTS设置权重(数学权重2，英语权重1)，AGGREGATE取MAX 18. 127.0.0.1:6379> zinterstore weighted_scores 2 math_scores english_scores WEIGHTS 2 1 AGGREGATE MAX 19. (integer) 3 20. 127.0.0.1:6379> zrange weighted_scores 0 -1 WITHSCORES 21. 1) "张三" 22. 2) "180" # max(90*2=180, 88*1=88)
AI写代码bash
![]()
```
* * *
#### 2.2.2zunionstore
**定义** ：计算多个有序集合的并集并将结果存储在新的有序集合中
**语法** ：
```
zunionstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]
AI写代码bash
```
**示例** ：
``` 1. # 计算两科成绩并集(所有参加任一考试的学生)，取分数最大值 2. 127.0.0.1:6379> zunionstore best_scores 2 math_scores english_scores AGGREGATE MAX 3. (integer) 4 # 4个学生(包含只参加英语的赵六) 4. 127.0.0.1:6379> zrange best_scores 0 -1 WITHSCORES 5. 1) "赵六" 6. 2) "75" # 只有英语成绩 7. 3) "李四" 8. 4) "92" # 英语92>数学85 9. 5) "张三" 10. 6) "90" # 数学90>英语88 11. 7) "王五" 12. 8) "95" # 数学95>英语80
AI写代码bash
![]()
```
* * *
### 2.3内部编码
zset有两种内部编码实现，Redis会根据集合大小自动选择更高效的存储方式：
#### 2.3.1ziplist（压缩列表）
**适用场景** ：当有序集合的成员数量少于zset-max-ziplist-entries（默认128）且每个成员长度小于zset-max-ziplist-value（默认64字节）时使用。
**结构特点** ： * 连续内存存储，节省空间 * 成员和分数交替存储：[score1, member1, score2, member2, ...] * 按分数升序排列 * 查找时间复杂度O(n)，适合小型集合
**UML结构表示** ：
![]()
#### 2.3.2skiplist（跳表）
**适用场景** ：当集合大小超过ziplist阈值时自动转换为跳表结构。
**结构特点** ： * 由多层有序链表组成，底层是完整链表，上层是索引层 * 支持平均O(log n)、最坏O(n)的查找复杂度 * 每个节点包含：成员(member)、分数(score)、后退指针(backward)、多个前进指针(forward)
**UML结构表示** ：
![]()
**转换机制** ：Redis会在zset添加成员时检查是否超过ziplist阈值，一旦超过会自动转换为skiplist结构，但转换是单向的（不会从skiplist转回ziplist）。
* * *
### 2.4使用场景
zset凭借其"有序性+唯一性+快速操作"的特性，在实际开发中有丰富的应用场景：
#### 2.4.1排行榜系统
**应用原理** ：利用zset的自动排序和分数更新能力，实现实时更新的排行榜。
**实现方案** ： * 以用户ID为member，以统计值（如分数、销量、播放量）为score * 使用zadd/zincrby更新数据 * 使用zrange/zrevrange获取排名列表 * 使用zrank/zrevrank获取用户排名
**代码示例（Java）** ：
``` 1. // Spring Data Redis示例：实现视频播放量排行榜 2. 3.
public class VideoRankService { 4. private final String RANK_KEY = "video:play:rank"; 5. private final RedisTemplate redisTemplate; 6. // 构造函数注入RedisTemplate 7. public VideoRankService(RedisTemplate redisTemplate) { 8. this.redisTemplate = redisTemplate; 9. } 10. // 增加视频播放量 11. public void incrementPlayCount(Long videoId) { 12. // 使用zincrby给指定videoId加1分 13. redisTemplate.opsForZSet().incrementScore(RANK_KEY, videoId, 1); 14. } 15. // 获取Top10视频 16. public List> getTop10Videos() { 17. // 获取分数从高到低的前10名 18. Set> top10 = redisTemplate.opsForZSet() 19. .reverseRangeWithScores(RANK_KEY, 0, 9); 20. List> result = new ArrayList<>(); 21. if (top10 != null) { 22. int rank = 1; 23. for (ZSetOperations.TypedTuple tuple : top10) { 24. Map videoInfo = new HashMap<>(); 25. videoInfo.put("rank", rank++); 26. videoInfo.put("videoId", tuple.getValue()); 27. videoInfo.put("playCount", tuple.getScore().longValue()); 28. result.add(videoInfo); 29. } 30. } 31. return result; 32. } 33. // 获取指定视频的排名和播放量 34. public Map getVideoRank(Long videoId) { 35. Map result = new HashMap<>(); 36. // 获取排名(降序，从0开始) 37. Long rank = redisTemplate.opsForZSet().reverseRank(RANK_KEY, videoId); 38. // 获取分数(播放量) 39. Double score = redisTemplate.opsForZSet().score(RANK_KEY, videoId); 40. result.put("videoId", videoId); 41. result.put("rank", rank != null ? rank + 1 : null); // 排名从1开始显示 42. result.put("playCount", score != null ? score.longValue() : 0); 43. return result; 44. } 45. }
AI写代码java运行
![]()
```
**优化建议** ： * 热门排行榜可定期缓存结果，减轻Redis压力 * 对超大榜单（百万级用户）可使用zrangebyscore分页查询 * 可结合zinterstore实现多维度综合排名
* * *
#### 2.4.2延迟任务
**应用原理** ：利用zset的分数排序特性，将任务执行时间戳作为score，实现定时任务调度。
**实现方案** ： * 将任务ID作为member，执行时间戳(timestamp)作为score * 定时（或阻塞式）从zset中获取分数小于当前时间的任务 * 使用bzpopmin实现阻塞式获取，避免轮询空转
**架构示意图** ：
``` 1.
+----------------+ +----------------+ +----------------+ 2. | | | | | | 3. | 任务生产者 |--->| Redis ZSet | redisTemplate; 5. private final ExecutorService executor = Executors.newFixedThreadPool(5); 6. // 添加延迟任务 7. public void addDelayTask(String taskId, long delaySeconds, String taskData) { 8. // 计算执行时间戳(当前时间+延迟秒数) 9. long executeTime = System.currentTimeMillis() / 1000 + delaySeconds; 10. // 存储任务元数据(实际项目可序列化对象) 11. redisTemplate.opsForValue().set("task:data:" + taskId, taskData); 12. // 添加到zset 13. redisTemplate.opsForZSet().add(TASK_KEY, taskId, executeTime); 14. } 15. // 启动任务消费者 16. 17. public void startConsumer() { 18. new Thread(() -> { 19. while (!Thread.currentThread().isInterrupted()) { 20. try { 21. // 阻塞式获取当前时间前的任务(score > tasks = 25. redisTemplate.opsForZSet().rangeByScoreWithScores(TASK_KEY, 0, now, 0, 10); 26. if (tasks != null && !tasks.isEmpty()) { 27. for (ZSetOperations.TypedTuple task : tasks) { 28. String taskId = task.getValue().toString(); 29. // 从zset中删除任务 30. redisTemplate.opsForZSet().remove(TASK_KEY, taskId); 31. // 获取任务数据 32. String taskData = redisTemplate.opsForValue().get("task:data:" + taskId).toString(); 33. // 异步执行任务 34. executor.submit(() -> executeTask(taskId, taskData)); 35. } 36. } else { 37. // 没有任务时短暂休眠 38. Thread.sleep(1000); 39. } 40. } catch (Exception e) { 41. log.error("延迟任务消费异常", e); 42. } 43. } 44. }, "delay-task-consumer").start(); 45. } 46. // 执行任务 47. private void executeTask(String taskId, String taskData) { 48. try { 49. // 实际任务逻辑... 50. log.info("执行延迟任务: {}，数据: {}", taskId, taskData); 51. } finally { 52. // 清理任务数据 53. redisTemplate.delete("task:data:" + taskId); 54. } 55. } 56. }
AI写代码java运行
![]()
```
**注意事项** ： * 分布式环境需考虑任务重复消费问题，可通过Redis的分布式锁解决 * 任务执行失败需要有重试机制 * 大量任务到期时可能造成消费峰值，建议控制每次获取的任务数量
* * *
#### 2.4.3去重+排序的数据集合
**应用原理** ：利用zset的成员唯一性和分数排序特性，实现自动去重并保持有序的数据集合。
**典型场景** ： * 用户最近浏览商品列表（按时间排序，自动去重） * 热门搜索关键词（按搜索次数排序，避免重复） * 接口调用频率限制（按时间戳记录，控制单位时间请求数）
**实现示例** ：用户最近浏览记录
``` 1. // 记录用户浏览商品 2.
public void recordView(Long userId, Long productId) { 3. String key = "user:view:" + userId; 4. long timestamp = System.currentTimeMillis(); // 用时间戳作为score 5. // 添加浏览记录(XX:只更新已存在成员，保证score是最新时间) 6. redisTemplate.opsForZSet().add(key, productId, timestamp); 7. // 只保留最近100条记录(移除排名100以后的成员) 8. redisTemplate.opsForZSet().removeRange(key, 0, -101); 9. } 10. // 获取用户最近浏览的10条商品 11.
public List getRecentViews(Long userId, int count) { 12. String key = "user:view:" + userId; 13. // 降序获取(最新浏览的在前) 14. Set products = redisTemplate.opsForZSet() 15. .reverseRange(key, 0, count - 1); 16. return products.stream() 17. .map(p -> Long.parseLong(p.toString())) 18. .collect(Collectors.toList()); 19. }
AI写代码java运行
![]()
```
## 3.小结
zset作为Redis中功能最丰富的数据类型之一，通过巧妙的"分数+成员"设计，完美解决了排序与去重的双重需求。本文从17个核心命令入手，详细讲解了其基本操作和集合间运算，深入剖析了ziplist和skiplist两种底层实现的适用场景，并通过排行榜、延迟任务、去重排序集合三个实战场景展示了zset的强大能力。
掌握zset的关键在于理解"分数是排序依据，成员是唯一标识"这一核心思想。在实际开发中，合理选择命令（如优先使用zrangebyscore而非zrange+zscore组合）、理解内部编码转换机制、结合业务场景设计key结构，才能充分发挥zset的性能优势。无论是构建高并发的实时排行榜，还是实现精准的延迟任务调度，zset都值得成为你Redis工具箱中的"瑞士军刀"。
![]()
确定要放弃本次机会？
福利倒计时
_:_ _:_
![]() 立减 ¥
普通VIP年卡可用
立即使用
![ 爱吃烤鸡翅的酸菜鱼 ](_81073317)
关注 关注 * !]() ![ ![]() 12
点赞 * !]() ![
踩 * ![ !]() ![ 11 ](javascript:;)
收藏
觉得还不错? 一键收藏 ![]() * ![ 0 ](_81073317/article/details/153976089?spm=1000.2115.3001.10524#commentBox)
评论 * ![ 分享 ](javascript:;)
复制链接
分享到 QQ
分享到新浪微博
![]()扫一扫 * ![打赏 打赏 ](javascript:;)
打赏 * ![]()
!打赏 打赏 ![]() 举报
![]() 举报
专栏目录 _Redis_ Streams在Spring Boot中的应用：构建可靠的消息队列解决方案【 _redis_ 实战 二】
todoitbo的博客
12-25 ![]() 13万+ 本文深入探讨了如何利用Spring Boot和 _Redis_ Streams构建一个高效、可靠的消息队列系统。从基本概念到高级实现，我们将一步步介绍如何在Spring Boot应用中集成 _Redis_ Streams，包括设置环境、消息的发布和订阅、处理消息以及监控和故障处理。通过本文，你将获得宝贵的实践知识，帮助你构建出能够处理高并发、高吞吐量场景的消息队列系统。 面试突袭： _Redis_ 测试 _全攻略_ ，从懵圈到逆袭的实战心得！
朱雀随云记的博客
08-21 ![]() 1020 _Redis_ 测试是确保系统稳定和高可用的关键，涵盖功能、性能、安全及持久化测试。功能测试需验证基本 _命令_ 、数据结构、事务等；性能测试关注吞吐量、延迟等指标，可使用 _redis_ -benchmark等工具模拟高并发；安全测试包括访问控制、加密等验证；持久化测试需确保RDB/AOF可靠性。通过系统化测试，可显著降低故障率，提升系统稳定性。掌握 _Redis_ 测试不仅能优化 _缓存_ 配置，还可避免生产事故，是分布式系统开发中的必备技能。
参与评论 您还未登录，请先 登录 后发表或查看评论 07-_Redis_ 基础操作 _全攻略_ ：从键管理到数据类型判断
编程实战派-李工，专注编程领域
09-14 ![]() 872 本文围绕 _Redis_ 基础操作展开，先解析 _Redis_ 键值存储本质与键命名规范，再按 “先操作键、后查看键” 逻辑，详细讲解 SET（字符串键赋值）、GET（字符串键取值）、EXISTS（判断键存在）、DEL（删除键）、TYPE（判断键数据类型）、KEYS（匹配查询键）6 大核心 _命令_ 的格式、返回值与实操案例，同时给出生产环境禁用 KEYS、误删键恢复、 _命令_ 与键名大小写区分等避坑指南，帮助新手掌握 _Redis_ 键管理核心方法，为后续复杂数据类型学习奠定基础。 5分钟上手Another _Redis_ DesktopManager：从安装到高级功能 _全攻略_
gitblog_00331的博客
09-09 ![]() 230 你是否还在为 _Redis_ _命令_ 行操作繁琐而头疼？是否在寻找一款跨平台、高性能且易用的 _Redis_ 管理工具？本文将 _带_ 你 _快速_ 掌握Another _Redis_ DesktopManager（下称ARDM）的核心功能，从基础安装到高级配置，让 _Redis_ 管理效率提升10倍。读完本文你将学会：3步完成安装配置、5种数据类型可视化管理、SSH/SSL安全连接技巧，以及自定义格式化等高级功能。 ## 关于ARDM Ano... _Redis_ 入门指南：基础概念、安装配置与 _命令_ 行操作详解
java2cy
04-23 ![]() 1012 _Redis_ 的深度应用需要持续实践和经验积累，建议结合官方文档与社区资源，关注新版本特性演进，构建高性能、高可靠的 _缓存_ 解决方案。通过本指南的系统学习，您已掌握 _Redis_ 从基础概念到企业级应用的完整知识体系。：内存访问速度远超磁盘I/O，单线程即可充分利用CPU。控制Key长度：不超过44字节（ _Redis_ 优化分片）使用CRC16算法分片（16384个槽）避免特殊字符：统一使用小写字母+下划线。：单线程避免了多线程的竞争和同步问题。：二进制压缩格式， _快速_ 恢复大数据集。：可能丢失最后一次快照后的数据。 深度好文| _Redis_ 面试 _全攻略_
过往记忆大数据
02-28 ![]() 2359 0x00.前言 _Redis_ 是跨语言的共同技术点，无论是 _Java_ 还是C++都会问到，所以是个高频面试点。笔者是2017年才开始接触 _Redis_ 的，期间自己搭过单机版和集群版，不过现在大一些的公... 1024程序员节橙子勋章获取 _全攻略_ ：5步教你 _快速_ 通关拿奖
FuncIsle的博客
09-28 ![]() 681 auto-generated _Redis_ _全攻略_
gongpulin的博客
05-05 ![]() 1754 0x00.前言 _Redis_ 是跨语言的共同技术点，无论是 _Java_ 还是C++都会问到，所以是个高频面试点。 笔者是2017年才开始接触 _Redis_ 的，期间自己搭过单机版和集群版，不过现在大一些的公司都完全是运维来实现的，我们使用者只需要在web页面进行相关申请即可，很多细节都被屏蔽了，这样当然很方便啦，不过我们还是要深入理解一下的。 在工作几年中笔者接触过 _Redis_ 、类 _Redis_ 的SSDB和Pik... _Redis_ 面试 _全攻略_ 、面试题大集合
ifknow
07-27 ![]() 4844 目录0.前言1._Redis_ 往事2._Redis_ 的江湖地位3.聊聊实战4.底层实现热点题目Q1 _:_ _Redis_ 常用五种数据类型是如何实现的？Q2 _:_ _Redis_ 的SDS和C中字符串相比有什么优势？Q3 _:__Redis_ 的字典是如何实现的？简述渐进式rehash的过程。Q4 _:_ 跳跃链表了解吗？ _Redis_ 的 _Zset_ 如何使用跳表实现的？Q5 _:__Redis_ 为什么使用单线程？讲讲 _Redis_ 网络模型以及单线程如何协调各种事件运行起来的？Q6 _:_ 了解 _Redis_ 的内存回收吗？讲讲你的理解1.1 为什么要回收内存？1.2 内存从哪里回收？1.3 _Redis_ 与 Spark 整合实战：大数据实时处理的最佳拍档
小程序开发
09-02 ![]() 914 本文将从“理论基础→环境搭建→实战案例→优化进阶”全流程，手把手 _带_ 你掌握 _Redis_ 与 Spark 的整合技术。我们会先理解二者的协作逻辑，再搭建完整的开发环境，接着通过3个递进式案例（基础数据读写→实时日志分析→实时风控规则引擎）实战演练，最后深入探讨数据一致性、性能优化、高可用等核心问题。至此，我们已完成 _Redis_ 和 Spark 的环境搭建，并配置了整合所需的依赖。核心目标是：让 Spark 能通过与 _Redis_ 建立连接，实现数据的双向流转。 API网关Python开发 _全攻略_ （从零搭建到生产级部署）
VarChat的博客
10-03 ![]() 788 掌握API网关Python开发核心方法，从零搭建高性能服务路由与鉴权体系。涵盖微服务通信、请求限流、日志监控等生产级场景，基于Flask+JWT+_Redis_ 实现高可用架构。实用技巧与部署优化全解析，值得收藏。 【 _数据库_ 技术】 _Redis_ 内存 _数据库_ 详解：从基础概念到 _应用场景_ 与数据类型操作
08-01 它采用键值对存储方式，支持多种数据类型（如String、Hash、List、Set、 _Zset_ ），并提供丰富的操作 _命令_ 。 _Redis_ 的 _应用场景_ 广泛，包括电商网站的商品排行、秒杀活动、直播平台的好友列表等。此外， _Redis_ 还具备数据过期... 【 _Redis_ 】 _ZSET_ 使用介绍：有序集合的进阶应用
tr6666的博客
08-13 ![]() 930 本文介绍了 _Redis_ 中的有序集合(_ZSET_)这一数据类型，它兼具集合的唯一性和有序列表的特性。 _ZSET_ 通过跳跃表和哈希表协同工作，实现高效的元素存储与排序。文章详细讲解了 _ZSET_ 的核心特性、数据结构原理、常用 _命令_(如ZADD、ZSCORE、ZRANGE等)以及高级 _应用场景_(排行榜、延时任务等)，并提供了使用注意事项。 _ZSET_ 凭借其有序存储和高效查询的特点，是处理排名、计分等场景的利器，合理使用可以显著提升业务系统性能。 _redis_ _zset_ 详解：排行榜绝佳选择
修己xj的博客
04-27 ![]() 1624 通过本文的介绍，你学会了如何利用Spring Boot和 _Redis_ 的 _ZSET_ 数据结构实现热门搜索功能，并深入了解了热搜词汇的实现细节。通过合理的设计和优化，可以为用户提供更好的搜索体验，同时也提升了应用程序的性能和可扩展性。 _Redis_ 下载安装教程与使用，以及基础知识的应用 最新发布
2302_80089018的博客
10-26 ![]() 643 该文章涵盖 _Redis_ '的详细安装步骤，保证手把手教你安装好 _Redis_ 、详细介绍了 _Redis_ 基础使用方法，以及基础知识的使用，基础知识部分的 _命令_ ，干货满满。 RTPENGINE _redis_ 测试
fs交流的博客
10-21 ![]() 145 我记得 yufeitao 写过一篇文章，回头找找，rtpengine 做 HA。把呼叫信息保存到 _redis_ ，目的是 rtpengine 重启后可以恢复呼叫。microsip1 呼叫 microsip2。顺便说下， yufeitao 是国人的骄傲。我逐步做一些很基础的测试，并分享出来。kamailio.cfg 不变。先写标题，再做测试，一步步来。运行 _redis_ -cli。microsip1 注册。microsip2 注册。 Go语言实战：入门篇-4：与 _数据库_ 、 _redis_ 、消息队列、API
ldmd284的博客
10-21 ![]() 915 本文介绍了使用Go语言调用API接口、连接 _Redis_ 、 _数据库_ 和消息队列的技术实践。主要内容包括：1) 通过gob和json格式解决Go处理中文乱码问题；2) 实现流式和非流式调用LLM API；3) 轮询获取AI生成图片并保存；4) 操作 _Redis_ 的各种数据结构；5) 连接PostgreSQL和MongoDB _数据库_ ；6) Kafka消息队列的生产消费实现。这些技术点涵盖了Web应用 _后端_ 开发的核心组件，为构建完整服务提供了解决方案。文章通过具体代码示例展示了各项功能的实现方法，为Go开发者提供了实用参考。 基于 _Redis_ 的布隆过滤器：高效的数据存在性检查
home_liang的博客
10-21 ![]() 577 本文介绍了布隆过滤器（Bloom Filter）的原理与应用。布隆过滤器是一种空间效率高的概率型数据结构，用于 _快速_ 判断元素是否属于集合，具有查询速度快、内存占用小的特点，但存在一定的误判率。文章详细解析了其工作原理，包括位数组和哈希函数的使用机制，并分析了其优缺点。此外，介绍了 _Redis_ Bloom模块在 _Redis_ 中的实现方式，提供了Python操作示例代码，展示了如何创建、添加和查询布隆过滤器。最后列举了布隆过滤器在数据去重、 _缓存_ 穿透防护、反作弊等场景的典型应用。 _Redis_ （78） 如何设置 _Redis_ 的 _缓存_ 失效策略？
qq_43012298的博客
10-23 ![]() 781 _Redis_ _缓存_ 失效策略设置指南：1)通过EXPIRE/SETEX等 _命令_ 设置键的过期时间(秒/毫秒/时间戳)；2)在 _redis_.conf中配置全局策略(volatile-lru/allkeys-lru等)；3)内存超限时按LRU等策略自动淘汰键；4)使用TTL/PTTL查询剩余时间，PERSIST取消过期。合理配置策略能优化内存使用，提升系统性能。提供了 _Java_ 示例代码演示具体实现方法。 * 关于我们 * 招贤纳士 * 商务合作 * 寻求报道 * ![]() 400-660-0108 * ![]() * !]() [在线客服 * 工作时间 8:30-22:00 * !]()[公安备案号11010502030143 * 京ICP备19004658号 * 京网文〔2020〕1039-165号 * 经营性网站备案信息 * 北京互联网违法和不良信息举报中心 * 家长监护 * 网络110报警服务 * 中国互联网举报中心 * Chrome商店下载 * 账号管理规范 * 版权与免责声明 * 版权申诉 * 出版物许可证 * 营业执照 * ©1999-2025北京创新乐知网络技术有限公司 ![ ](_81073317)
[ 爱吃烤鸡翅的酸菜鱼 ](_81073317 "爱吃烤鸡翅的酸菜鱼")
博客等级 ![]()
码龄2年
![]() 优质创作者: Java技术领域 [ 109
原创
](_81073317) 5400
点赞 4862
收藏 1万+
粉丝
关注
私信 ![ ]() ![ ](_source=251024_vip_blogleftbanner) ![ ](_source=blog)
### TA的精选 * 新 从零掌握贪心算法Java版：LeetCode 10题实战解析（上）
829 阅读 * 新 快速掌握【Redis】Set：从基础命令到内部编码
5032 阅读 * 热 【MyBatis】杂谈篇：提升数据库安全与性能的4大实战技巧（防注入/动态SQL/模糊优化/连接池）
23651 阅读 * 热 IDEA高效开发：Database Navigator插件安装与核心使用指南
15536 阅读 * 热 从单机架构到分布式：Redis为何成为架构升级的关键一环？
12792 阅读
查看更多 ![
2025 10月 5篇 09月 11篇 08月 6篇 07月 10篇 06月 2篇 05月 7篇 04月 6篇 03月 8篇 02月 2篇
2024年51篇
### 大家在看 * 智能座舱架构与关键技 * 出新版小红书x-mini-mua、x-mini-sig算法 * 链表：动态数据结构之美 * CNN模型改ViT模型记录 ![ 816 ](_70777445/article/details/153915040) * B站视频下载工具BIliDownloader v1.3.15绿色版 ![ 86 ](_666/article/details/153966307)
### 分类专栏 * ![ redis ](_81073317/category_13014924.html) 6篇 * ![ Git ](_81073317/category_13048702.html) 2篇 * ![ Spring ](_81073317/category_13034514.html) 14篇 * ![ MyBatis ](_81073317/category_12976993.html) 3篇 * ![ MySQL ](_81073317/category_12976907.html) 6篇 * ![ Java初阶学习 ](_81073317/category_12929357.html) 10篇 * ![ C语言刷题分享 ](_81073317/category_12621084.html) 18篇
展开全部 !]() 收起 ![
上一篇： 从零掌握贪心算法Java版：LeetCode 10题实战解析（上）
### 目录 1. 1.前言 2. 插播一条消息~ 3. 2.正文 4. 1. 2.1常见命令 2. 1. 2.1.1zadd 2. 2.1.2zcard 3. 2.1.3zcount 4. 2.1.4zrange 5. 2.1.5zrevrange 6. 2.1.6zrangebyscore 7. 2.1.7zpopmax 8. 2.1.8bzpopmax 9. 2.1.9zpopmin 10. 2.1.10bzpopmin 11. 2.1.11zrank 12. 2.1.12zrevrank 13. 2.1.13zscore 14. 2.1.14zrem 15. 2.1.15zremrangebyrank 16. 2.1.16zremrangebyscore 17. 2.1.17zincrby 3. 2.2集合间操作 4. 1. 2.2.1zinterstore 2. 2.2.2zunionstore 5. 2.3内部编码 6. 1. 2.3.1ziplist（压缩列表） 2. 2.3.2skiplist（跳表） 7. 2.4使用场景 8. 1. 2.4.1排行榜系统 2. 2.4.2延迟任务 3. 2.4.3去重+排序的数据集合 5. 3.小结
展开全部 ![]()
收起 ![]()
### 目录 1. 1.前言 2. 插播一条消息~ 3. 2.正文 4. 1. 2.1常见命令 2. 1. 2.1.1zadd 2. 2.1.2zcard 3. 2.1.3zcount 4. 2.1.4zrange 5. 2.1.5zrevrange 6. 2.1.6zrangebyscore 7. 2.1.7zpopmax 8. 2.1.8bzpopmax 9. 2.1.9zpopmin 10. 2.1.10bzpopmin 11. 2.1.11zrank 12. 2.1.12zrevrank 13. 2.1.13zscore 14. 2.1.14zrem 15. 2.1.15zremrangebyrank 16. 2.1.16zremrangebyscore 17. 2.1.17zincrby 3. 2.2集合间操作 4. 1. 2.2.1zinterstore 2. 2.2.2zunionstore 5. 2.3内部编码 6. 1. 2.3.1ziplist（压缩列表） 2. 2.3.2skiplist（跳表） 7. 2.4使用场景 8. 1. 2.4.1排行榜系统 2. 2.4.2延迟任务 3. 2.4.3去重+排序的数据集合 5. 3.小结
展开全部 ![]()
收起 ![]()
上一篇： 从零掌握贪心算法Java版：LeetCode 10题实战解析（上）
### 分类专栏 * ![ redis ](_81073317/category_13014924.html) 6篇 * ![ Git ](_81073317/category_13048702.html) 2篇 * ![ Spring ](_81073317/category_13034514.html) 14篇 * ![ MyBatis ](_81073317/category_12976993.html) 3篇 * ![ MySQL ](_81073317/category_12976907.html) 6篇 * ![ Java初阶学习 ](_81073317/category_12929357.html) 10篇 * ![ C语言刷题分享 ](_81073317/category_12621084.html) 18篇
展开全部 !]() 收起 ![
登录后您可以享受以下权益： * ![](_81073317/article/details/153976089?spm=1000.2115.3001.10524)免费复制代码 * ![](_81073317/article/details/153976089?spm=1000.2115.3001.10524)和博主大V互动 * ![](_81073317/article/details/153976089?spm=1000.2115.3001.10524)下载海量资源 * ![](_81073317/article/details/153976089?spm=1000.2115.3001.10524)发动态/写文章/加入社区
×立即登录
评论 ![]()
!]()被折叠的 [为什么被折叠? ![
查看更多评论![]()
添加红包
祝福语
请填写红包祝福语或标题
红包数量
个
红包个数最小为10个
红包总金额
元
红包金额最低5元
余额支付
当前余额3.43元 前往充值 >
需支付：10.00元
取消 确定
成就一亿技术人!
领取后你会自动成为博主和红包主的粉丝 规则 ![ ](_81073317/article/details/153976089?spm=1000.2115.3001.10524)
hope_wisdom
发出的红包
打赏作者!]() [ ![ ](_81073317)
爱吃烤鸡翅的酸菜鱼
希望大家对我多多支持喔~
¥1 ¥2 ¥4 ¥6 ¥10 ¥20
扫码支付：¥1
![]() 获取中
!]() ![ 扫码支付
您的余额不足，请更换扫码支付或充值
打赏作者
实付元
使用余额支付
![]() 点击重新获取
!]()![扫码支付
钱包余额 0
![]()
抵扣说明：
1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。
2.余额无法直接购买下载，可以购买VIP、付费专栏及课程。
![
![](_81073317/article/details/153976089?spm=1000.2115.3001.10524)
确定取消![]()
举报
![]()
选择你想要举报的内容（必选） * 内容涉黄 * 政治相关 * 内容抄袭 * 涉嫌广告 * 内容侵权 * 侮辱谩骂 * 样式问题 * 其他
原文链接（必填）
请选择具体原因（必选） * 包含不实信息 * 涉及个人隐私
请选择具体原因（必选） * 侮辱谩骂 * 诽谤
请选择具体原因（必选） * 搬家样式 * 博文样式
补充说明（选填）
取消
确定
!]() 下载APP ![程序员都在用的中文IT技术交流社区 程序员都在用的中文IT技术交流社区 公众号 !专业的中文 IT 技术社区，与千万技术人共成长 专业的中文 IT 技术社区，与千万技术人共成长 视频号 !关注【CSDN】视频号，行业资讯、技术分享精彩不断，直播好礼送不停！ 关注【CSDN】视频号，行业资讯、技术分享精彩不断，直播好礼送不停！ !]() 客服 ![ 返回顶部